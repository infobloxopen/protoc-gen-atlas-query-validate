package plugin

import (
	"errors"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
	"github.com/infobloxopen/protoc-gen-atlas-query-validate/util"
)

const (
	filtering                          = "infoblox.api.Filtering"
	sorting                            = "infoblox.api.Sorting"
	fieldSelection                     = "infoblox.api.FieldSelection"
	messagesValidationVarSuffix        = "MessagesRequireQueryValidation"
	methodFilteringVarSuffix           = "MethodsRequireFilteringValidation"
	methodSortingVarSuffix             = "MethodsRequireSortingValidation"
	methodFieldSelectionVarSuffix      = "MethodsRequireFieldSelectionValidation"
	validateFilteringMethodSuffix      = "ValidateFiltering"
	validateSortingMethodSuffix        = "ValidateSorting"
	validateFieldSelectionMethodSuffix = "ValidateFieldSelection"

	protoTypeTimestamp   = "google.protobuf.Timestamp"
	protoTypeUUID        = "gorm.types.UUID"
	protoTypeUUIDValue   = "gorm.types.UUIDValue"
	protoTypeResource    = "atlas.rpc.Identifier"
	protoTypeInet        = "gorm.types.InetValue"
	protoTypeJSONValue   = "gorm.types.JSONValue"
	protoTypeStringValue = "google.protobuf.StringValue"
	protoTypeDoubleValue = "google.protobuf.DoubleValue"
	protoTypeFloatValue  = "google.protobuf.FloatValue"
	protoTypeInt32Value  = "google.protobuf.Int32Value"
	protoTypeInt64Value  = "google.protobuf.Int64Value"
	protoTypeUInt32Value = "google.protobuf.UInt32Value"
	protoTypeUInt64Value = "google.protobuf.UInt64Value"
	protoTypeBoolValue   = "google.protobuf.BoolValue"
)

// QueryValidateBuilder implements the plugin interface and creates validations for collection operation parameters code from .protos
type QueryValidateBuilder struct {
	plugin                                  *protogen.Plugin
	messageTypes                            map[string]*protogen.Message
	currentPackage                          string
	currentFile                             string
	requiredFilteringValidationVarName      string
	requiredSortingValidationVarName        string
	validateFilteringMethodName             string
	validateSortingMethodName               string
	validateFieldSelectionMethodName        string
	requiredFieldSelectionValidationVarName string
}

// Name identifies the plugin
func (p *QueryValidateBuilder) Name() string {
	return "atlas-query-validate"
}

func New(opts protogen.Options, request *pluginpb.CodeGeneratorRequest) (*QueryValidateBuilder, error) {
	plugin, err := opts.New(request)
	if err != nil {
		return nil, err
	}
	return &QueryValidateBuilder{
		plugin:       plugin,
		messageTypes: map[string]*protogen.Message{},
	}, nil
}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (p *QueryValidateBuilder) Generate() (*pluginpb.CodeGeneratorResponse, error) {

	for _, file := range p.plugin.Files {
		for _, msg := range file.Messages {
			copy := *msg
			p.messageTypes[string(msg.Desc.FullName())] = &copy
		}
	}

	for _, protoFile := range p.plugin.Files {
		fileName := protoFile.GeneratedFilenamePrefix + ".pb.atlas.query.validate.go"
		if !protoFile.Generate {
			continue
		}

		g := p.plugin.NewGeneratedFile(fileName, ".")
		pathPieces := strings.Split(protoFile.GeneratedFilenamePrefix, "/")
		shortName := pathPieces[len(pathPieces)-1]

		g.P("package ", protoFile.GoPackageName)
		p.currentPackage = protoFile.GoImportPath.String()
		p.requiredFilteringValidationVarName = util.Camel(shortName) + methodFilteringVarSuffix
		p.requiredSortingValidationVarName = util.Camel(shortName) + methodSortingVarSuffix
		p.requiredFieldSelectionValidationVarName = util.Camel(shortName) + methodFieldSelectionVarSuffix
		p.validateFilteringMethodName = util.Camel(shortName) + validateFilteringMethodSuffix
		p.validateSortingMethodName = util.Camel(shortName) + validateSortingMethodSuffix
		p.validateFieldSelectionMethodName = util.Camel(shortName) + validateFieldSelectionMethodSuffix

		p.genValidationData(g, protoFile)

		p.genValidateFiltering(g)
		p.genValidateSorting(g)
		p.genValidateFieldSelection(g)
	}

	return p.plugin.Response(), nil
}

func (p *QueryValidateBuilder) genValidationData(g *protogen.GeneratedFile, file *protogen.File) {
	p.genFiltering(g, file)
	p.genSorting(g, file)
	p.genFieldSelection(g, file)
}

func (p *QueryValidateBuilder) genFiltering(g *protogen.GeneratedFile, file *protogen.File) {
	generateImport("FilteringOption", "github.com/infobloxopen/protoc-gen-atlas-query-validate/options", g)
	g.P(`var `, p.requiredFilteringValidationVarName, ` = map[string]map[string]options.FilteringOption {`)
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			hasFiltering := p.hasFiltering(method.Input)
			outputMsg := method.Output
			resultMsg := p.getResultMessage(outputMsg)
			if hasFiltering && resultMsg != nil {
				g.P(`"`, fmt.Sprintf("/%s.%s/%s", file.GoPackageName, srv.GoName, method.GoName), `": map[string]options.FilteringOption{`)
				filteringInfo := p.getFilteringData(resultMsg)
				for _, v := range filteringInfo {
					var f string
					if len(v.option.Deny) != 0 {
						for _, d := range v.option.Deny {
							f += "options.QueryValidate_" + d.String() + `,`
						}
						f = `Deny: []options.QueryValidate_FilterOperator{` + f + `},`
					}
					t := `ValueType: options.QueryValidate_` + v.option.ValueType.String()
					g.P(`"`, v.fieldName, `": options.FilteringOption{`+f+t+`},`)
				}
				g.P(`},`)
			}
		}
	}
	g.P(`}`)
}

func (p *QueryValidateBuilder) genSorting(g *protogen.GeneratedFile, file *protogen.File) {
	g.P(`var `, p.requiredSortingValidationVarName, ` = map[string][]string {`)
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			hasSorting := p.hasSorting(method.Input)
			resultMsg := p.getResultMessage(method.Output)
			if hasSorting && resultMsg != nil {
				g.P(`"`, fmt.Sprintf("/%s.%s/%s", file.GoPackageName, srv.GoName, method.GoName), `": []string {`)
				sortingInfo := p.getSortingData(resultMsg)
				for _, v := range sortingInfo {
					g.P(`"`, v, `",`)
				}
				g.P(`},`)
			}
		}
	}
	g.P(`}`)
}

func (p *QueryValidateBuilder) genFieldSelection(g *protogen.GeneratedFile, file *protogen.File) {
	g.P(`var `, p.requiredFieldSelectionValidationVarName, ` = map[string][]string{`)
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			hasFieldSelection := p.hasFieldSelection(method.Input)
			resultMsg := p.getResultMessage(method.Output)
			if hasFieldSelection && resultMsg != nil {
				g.P(`"`, fmt.Sprintf("/%s.%s/%s", file.GoPackageName, srv.GoName, method.GoName), `": {`)
				fields := p.getFieldSelectionData(resultMsg)
				for _, field := range fields {
					g.P(fmt.Sprintf(`"%s",`, field))
				}
				g.P(`},`)
			}
		}
	}
	g.P(`}`)
}

func (p *QueryValidateBuilder) hasFieldSelection(msg *protogen.Message) bool {
	for _, msgField := range msg.Fields {
		if msgField.Message.Desc.FullName() == fieldSelection {
			return true
		}
	}
	return false
}

func (p *QueryValidateBuilder) hasFiltering(msg *protogen.Message) bool {
	for _, msgField := range msg.Fields {
		if msgField.Message.Desc.FullName() == filtering {
			return true
		}
	}
	return false
}

func (p *QueryValidateBuilder) hasSorting(msg *protogen.Message) bool {
	for _, msgField := range msg.Fields {
		if msgField.Message.Desc.FullName() == sorting {
			return true
		}
	}
	return false
}

func (p *QueryValidateBuilder) getResultMessage(msg *protogen.Message) *protogen.Message {
	for _, field := range msg.Fields {
		switch field.GoName {
		case "Result", "Results":
			return field.Message
		}
	}
	return nil
}

type fieldValidate struct {
	fieldName string
	option    options.FilteringOption
}

// stubField contains and flattens the necessary data about a field so
// that synthetic fields can be processed in the same way as protogen.Fields
// (the protoreflect.FieldDescriptor implementation is defined internally,
// so creating a custom protogen.Field doesn't work well)
type stubField struct {
	fieldName   string
	isList      bool
	isMap       bool
	isSynthetic bool
	isEnum      bool
	typeName    string
	kind        protoreflect.Kind
	option      *options.QueryValidate
	msg         *protogen.Message
}

func newStubField(field *protogen.Field) *stubField {
	typeName := field.Desc.Kind().GoString()
	if field.Message != nil {
		typeName = string(field.Message.Desc.FullName())
	}
	return &stubField{
		fieldName:   string(field.Desc.Name()),
		isList:      field.Desc.IsList(),
		isMap:       field.Desc.IsMap(),
		kind:        field.Desc.Kind(),
		isSynthetic: false,
		typeName:    typeName,
		option:      getQueryValidationOptions(field),
		msg:         field.Message,
	}
}

func (p *QueryValidateBuilder) syntheticField(name string, o *options.QueryValidate) *stubField {
	if o.GetValueTypeUrl() == "" {
		return nil
	}

	url := strings.TrimPrefix(o.GetValueTypeUrl(), ".")
	msgType := p.messageTypes[url]
	if msgType == nil {
		p.plugin.Error(errors.New(`Cannot find named object of type ` + o.GetValueTypeUrl()))
	}

	f := &stubField{
		fieldName:   name,
		isList:      false,
		isMap:       false,
		isEnum:      false,
		isSynthetic: true,
		kind:        protoreflect.MessageKind,
		typeName:    string(msgType.Desc.Name()),
		option:      o,
		msg:         msgType,
	}
	return f
}

func (p *QueryValidateBuilder) getFilteringData(msg *protogen.Message) []fieldValidate {
	return p.getFilteringDataAux(msg, false)
}

func (p *QueryValidateBuilder) getFilteringDataAux(msg *protogen.Message, nested bool) []fieldValidate {

	var (
		data      []fieldValidate
		fields    []*stubField
		valueType options.QueryValidate_ValueType
	)

	for _, opts := range p.getMessageQueryValidationOptions(msg) {
		if f := p.syntheticField(opts.GetName(), opts.GetValue()); f != nil {
			fields = append(fields, f)
		} else {
			data = append(data, fieldValidate{
				fieldName: opts.GetName(),
				option: options.FilteringOption{
					ValueType: opts.GetValue().GetValueType(),
					Deny:      p.getDenyRules(opts.GetName(), opts.GetValue(), opts.GetValue().GetValueType()),
				},
			})
		}
	}

	for _, field := range msg.Fields {
		fields = append(fields, newStubField(field))
	}

	for _, field := range fields {
		opts := field.option

		fieldName := field.fieldName
		if field.typeName == protoTypeJSONValue {
			fieldName += ".*"
		}

		if valueType = opts.GetValueType(); valueType == options.QueryValidate_DEFAULT {
			if field.isList {
				data = append(data, fieldValidate{
					fieldName: fieldName,
					option: options.FilteringOption{
						ValueType: options.QueryValidate_DEFAULT,
						Deny: []options.QueryValidate_FilterOperator{
							options.QueryValidate_ALL,
						},
					},
				})
				continue
			}

			if valueType = getValueType(field); valueType == options.QueryValidate_DEFAULT {

				if nested {
					// TBD: Unrecognized vs. Not Allowed
					/*
						data = append(data, fieldValidate{
							fieldName: fieldName,
							option: options.FilteringOption{
								ValueType: options.QueryValidate_DEFAULT,
								Deny: []options.QueryValidate_FilterOperator{
									options.QueryValidate_ALL,
								},
							},
						})
					*/
					continue
				}

				if field.msg != nil && !field.isList && !field.isMap && opts.GetEnableNestedFields() {
					nestedMsg := field.msg

					for _, v := range p.getFilteringDataAux(nestedMsg, true) {
						if p.isAllowedNestedField(v.fieldName, opts) {
							data = append(data, fieldValidate{
								fieldName: fieldName + "." + v.fieldName,
								option:    v.option,
							})
						} else {
							// TBD: Unrecognized vs. Not Allowed
							/*
								data = append(data, fieldValidate{
									fieldName: fieldName + "." + v.fieldName,
									option: options.FilteringOption{
										ValueType: options.QueryValidate_DEFAULT,
										Deny: []options.QueryValidate_FilterOperator{
											options.QueryValidate_ALL,
										},
									},
								})
							*/
						}
					}

					continue
				}

				data = append(data, fieldValidate{
					fieldName: fieldName,
					option: options.FilteringOption{
						ValueType: options.QueryValidate_DEFAULT,
						Deny: []options.QueryValidate_FilterOperator{
							options.QueryValidate_ALL,
						},
					},
				})
				continue
			}
		}

		data = append(data, fieldValidate{fieldName: fieldName, option: options.FilteringOption{ValueType: valueType, Deny: p.getDenyRules(fieldName, opts, valueType)}})
	}
	return data
}

func (p *QueryValidateBuilder) isAllowedNestedField(n string, o *options.QueryValidate) bool {
	if o == nil || len(o.NestedFields) == 0 {
		return true
	}

	for _, v := range o.NestedFields {
		if v == n {
			return true
		}
	}

	return false
}

func getValueType(field *stubField) options.QueryValidate_ValueType {
	if field.isEnum {
		return options.QueryValidate_STRING
	}
	switch field.kind {
	case protoreflect.StringKind:
		return options.QueryValidate_STRING
	case protoreflect.BoolKind:
		return options.QueryValidate_BOOL
	case protoreflect.DoubleKind,
		protoreflect.Fixed32Kind,
		protoreflect.Fixed64Kind,
		protoreflect.Int32Kind,
		protoreflect.Int64Kind,
		protoreflect.FloatKind:
		return options.QueryValidate_NUMBER
	case protoreflect.MessageKind:
		switch string(field.msg.Desc.FullName()) {
		case protoTypeResource,
			protoTypeTimestamp,
			protoTypeUUID,
			protoTypeUUIDValue,
			protoTypeInet,
			protoTypeStringValue,
			protoTypeJSONValue:
			return options.QueryValidate_STRING
		case protoTypeDoubleValue,
			protoTypeFloatValue,
			protoTypeInt32Value,
			protoTypeInt64Value,
			protoTypeUInt32Value,
			protoTypeUInt64Value:
			return options.QueryValidate_NUMBER
		case protoTypeBoolValue:
			return options.QueryValidate_BOOL
		default:
			return options.QueryValidate_DEFAULT
		}
	default:
		return options.QueryValidate_DEFAULT
	}
}

func (p *QueryValidateBuilder) getSortingData(msg *protogen.Message) []string {
	return p.getSortingDataAux(msg, false)
}

func (p *QueryValidateBuilder) getSortingDataAux(msg *protogen.Message, nested bool) []string {

	var (
		data      []string
		fields    []*stubField
		valueType options.QueryValidate_ValueType
	)

	for _, opts := range p.getMessageQueryValidationOptions(msg) {
		if f := p.syntheticField(opts.GetName(), opts.GetValue()); f != nil {
			fields = append(fields, f)
		} else if !opts.GetValue().GetSorting().GetDisable() {
			data = append(data, opts.GetName())
		}
	}

	for _, field := range msg.Fields {
		fields = append(fields, newStubField(field))
	}

	for _, field := range fields {

		if field.option.GetSorting().GetDisable() {
			continue
		}

		fieldName := field.fieldName
		if valueType = field.option.GetValueType(); valueType == options.QueryValidate_DEFAULT {

			if field.isList || field.isMap {
				continue
			}

			if valueType = getValueType(field); valueType == options.QueryValidate_DEFAULT {

				if nested {
					continue
				}

				if field.msg != nil && field.option.GetEnableNestedFields() {

					nestedMsg := field.msg
					for _, v := range p.getSortingDataAux(nestedMsg, true) {
						data = append(data, fieldName+"."+v)
					}
				}

				continue
			}
		}

		data = append(data, fieldName)
	}

	return data
}

func (p *QueryValidateBuilder) getFieldSelectionData(msg *protogen.Message) []string {
	return p.getFieldSelectionDataAux(msg, false)
}

func (p *QueryValidateBuilder) getFieldSelectionDataAux(msg *protogen.Message, nested bool) []string {

	var (
		data      []string
		fields    []*stubField
		valueType options.QueryValidate_ValueType
	)

	for _, opts := range p.getMessageQueryValidationOptions(msg) {
		if f := p.syntheticField(opts.GetName(), opts.GetValue()); f != nil {
			fields = append(fields, f)
		} else if !opts.GetValue().GetFieldSelection().GetDisable() {
			data = append(data, opts.GetName())
		}
	}

	for _, field := range msg.Fields {
		fields = append(fields, newStubField(field))
	}

	for _, field := range fields {

		if field.option.GetFieldSelection().GetDisable() {
			continue
		}

		fieldName := string(field.fieldName)
		if valueType = field.option.GetValueType(); valueType == options.QueryValidate_DEFAULT {

			if field.msg != nil && !field.isList && !field.isMap {
				switch field.typeName {
				case protoTypeResource,
					protoTypeTimestamp,
					protoTypeUUID,
					protoTypeUUIDValue,
					protoTypeInet,
					protoTypeStringValue:
				case protoTypeBoolValue:
				case protoTypeDoubleValue,
					protoTypeFloatValue,
					protoTypeInt32Value,
					protoTypeInt64Value,
					protoTypeUInt32Value,
					protoTypeUInt64Value:
				default:

					if nested {
						continue
					}

					nestedMsg := field.msg
					for _, v := range p.getFieldSelectionDataAux(nestedMsg, true) {
						data = append(data, fieldName+"."+v)
					}
				}
			}
		}

		data = append(data, fieldName)
	}

	return data
}

func (p *QueryValidateBuilder) getDenyRules(fieldName string, opts *options.QueryValidate, filterType options.QueryValidate_ValueType) []options.QueryValidate_FilterOperator {
	opsAllowed := opts.GetFiltering().GetAllow()
	opsDenied := opts.GetFiltering().GetDeny()

	if len(opsAllowed) > 0 && len(opsDenied) > 0 {
		panic(fieldName + ": both allow and deny options are not allowed")
	}

	if len(opsAllowed) == 0 && len(opsDenied) == 0 {
		return nil
	}

	var supportedOps []options.QueryValidate_FilterOperator
	if filterType == options.QueryValidate_NUMBER {
		supportedOps = []options.QueryValidate_FilterOperator{
			options.QueryValidate_EQ,
			options.QueryValidate_GT,
			options.QueryValidate_GE,
			options.QueryValidate_LT,
			options.QueryValidate_LE,
			options.QueryValidate_IN,
		}
	} else if filterType == options.QueryValidate_STRING {
		supportedOps = []options.QueryValidate_FilterOperator{
			options.QueryValidate_EQ,
			options.QueryValidate_MATCH,
			options.QueryValidate_GT,
			options.QueryValidate_GE,
			options.QueryValidate_LT,
			options.QueryValidate_LE,
			options.QueryValidate_IN,
			options.QueryValidate_IEQ,
		}
	} else if filterType == options.QueryValidate_BOOL {
		supportedOps = []options.QueryValidate_FilterOperator{
			options.QueryValidate_EQ,
			options.QueryValidate_IN,
		}
	}

	ops := opsAllowed
	if len(opsDenied) > 0 {
		ops = opsDenied
	}

	for _, item := range ops {
		var found bool
		for _, i := range supportedOps {
			if item == i {
				found = true
				break
			}
		}
		if !found && item != options.QueryValidate_ALL {
			panic(fmt.Sprintf("'%s'filtering operator is not supported for fieldValidate '%s'", item, fieldName))
		}
	}

	var res []options.QueryValidate_FilterOperator
	if len(opsAllowed) > 0 {
	OUTER:
		for _, op := range supportedOps {
			found := false
			for _, allowedOp := range ops {
				if allowedOp == options.QueryValidate_ALL {
					res = nil
					break OUTER
				}
				if op == allowedOp {
					found = true
					break
				}
			}
			if !found {
				res = append(res, op)
			}
		}
	} else {
		res = ops
		for _, op := range ops {
			if op == options.QueryValidate_ALL {
				res = []options.QueryValidate_FilterOperator{options.QueryValidate_ALL}
				break
			}
		}
	}
	return res
}

func (p *QueryValidateBuilder) genValidateFiltering(g *protogen.GeneratedFile) {
	generateImport("Filtering", "github.com/infobloxopen/atlas-app-toolkit/query", g)
	g.P(`func `, p.validateFilteringMethodName, `(methodName string, f *query.Filtering) error {`)
	g.P(`info, ok := `, p.requiredFilteringValidationVarName, `[methodName]`)
	g.P(`if !ok {`)
	g.P(`return nil`)
	g.P(`}`)
	g.P(`return options.ValidateFiltering(f, info)`)
	g.P(`}`)
}

func (p *QueryValidateBuilder) genValidateSorting(g *protogen.GeneratedFile) {
	g.P(`func `, p.validateSortingMethodName, `(methodName string, s *query.Sorting) error {`)
	g.P(`info, ok := `, p.requiredSortingValidationVarName, `[methodName]`)
	g.P(`if !ok {`)
	g.P(`return nil`)
	g.P(`}`)
	g.P(`return options.ValidateSorting(s, info)`)
	g.P(`}`)
}

func (p *QueryValidateBuilder) genValidateFieldSelection(g *protogen.GeneratedFile) {
	g.P(`func `, p.validateFieldSelectionMethodName, `(methodName string, s *query.FieldSelection) error {`)
	g.P(`info, ok := `, p.requiredFieldSelectionValidationVarName, `[methodName]`)
	g.P(`if !ok {`)
	g.P(`return nil`)
	g.P(`}`)
	g.P(`return options.ValidateFieldSelection(s, info)`)
	g.P(`}`)
}

func getQueryValidationOptions(field *protogen.Field) *options.QueryValidate {
	if field.Desc.Options() == nil {
		return nil
	}
	fOpts, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
	if !ok {
		return nil
	}
	v := proto.GetExtension(fOpts, options.E_Validate)
	opts, ok := v.(*options.QueryValidate)
	if !ok {
		return nil
	}

	if opts.GetValueTypeUrl() != "" {

		if len(opts.NestedFields) > 0 {
			opts.EnableNestedFields = true
		}

		if opts.Sorting == nil {
			opts.Sorting = &options.QueryValidate_Sorting{Disable: true}
		}

		if opts.FieldSelection == nil {
			opts.FieldSelection = &options.QueryValidate_FieldSelection{Disable: true}
		}
	}
	return opts
}

func (p *QueryValidateBuilder) getMessageQueryValidationOptions(msg *protogen.Message) []*options.MessageQueryValidate_QueryValidateEntry {
	if msg.Desc.Options() == nil {
		return nil
	}

	fOpts, ok := msg.Desc.Options().(*descriptorpb.MessageOptions)
	if !ok {
		return nil
	}
	v := proto.GetExtension(fOpts, options.E_Message)
	opts, ok := v.(*options.MessageQueryValidate)

	res := make([]*options.MessageQueryValidate_QueryValidateEntry, len(opts.GetValidate()))
	for i, opt := range opts.GetValidate() {

		if opt.GetName() == "" {
			panic(`empty synthetic validate option for message ` + msg.Desc.FullName())
		}

		o := opt.GetValue()
		if o == nil {
			panic(`empty synthetic validate option for field ` + string(msg.Desc.FullName()) + `.` + opt.GetName())
		}

		if len(o.NestedFields) > 0 {
			o.EnableNestedFields = true
		}

		if o.Sorting == nil {
			o.Sorting = &options.QueryValidate_Sorting{Disable: true}
		}

		if o.FieldSelection == nil {
			o.FieldSelection = &options.QueryValidate_FieldSelection{Disable: true}
		}

		res[i] = &options.MessageQueryValidate_QueryValidateEntry{Value: o, Name: opt.GetName()}
	}

	return res
}

func generateImport(name string, importPath string, g *protogen.GeneratedFile) string {
	return g.QualifiedGoIdent(protogen.GoIdent{
		GoName:       name,
		GoImportPath: protogen.GoImportPath(importPath),
	})
}
